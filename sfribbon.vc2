*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="sfribbon.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS sfribbon AS sfribbonbase OF "sfribbon.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="linBottom" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Line1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Line2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Line3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Line4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Line5" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: addtab		&& Adds a tab to the ribbon
		*m: adjusttabs		&& Adjusts the tabs so they align properly
		*m: gettabs		&& Returns a collection of tabs
		*m: selecttab		&& Fired when the specified tab is selected
		*m: width_assign
		*p: cselectedtab		&& The name of the selected pad
		*p: tabclass		&& The default tab class
		*p: tablibrary		&& The default tab library
		*p: themes		&& A collection of theme names
	*</DefinedPropArrayMethod>

	PROTECTED cselectedtab
	BackColor = 243,242,241
	controltype = Tab
	cselectedtab = 		&& The name of the selected pad
	Height = 130
	Name = "sfribbon"
	tabclass = SFRibbonTab		&& The default tab class
	tablibrary = SFRibbon.vcx		&& The default tab library
	themes = NULL		&& A collection of theme names
	Width = 450
	_memberdata = <VFPData>
		<memberdata name="shortcutmenu" display="ShortcutMenu"/>
		<memberdata name="showmenu" display="ShowMenu"/>
		<memberdata name="omenu" display="oMenu"/>
		<memberdata name="addtab" display="AddTab"/>
		<memberdata name="adjusttabs" display="AdjustTabs"/>
		<memberdata name="gettabs" display="GetTabs"/>
		<memberdata name="cselectedtab" display="cSelectedTab"/>
		<memberdata name="selecttab" display="SelectTab"/>
		<memberdata name="tabclass" display="TabClass"/>
		<memberdata name="tablibrary" display="TabLibrary"/>
		<memberdata name="themes" display="Themes"/>
		<memberdata name="width" display="Width"/>
		<memberdata name="width_assign" display="Width_Assign"/>
		</VFPData>

	ADD OBJECT 'linBottom' AS line WITH ;
		BorderColor = 210,208,206, ;
		Height = 0, ;
		Left = 0, ;
		Name = "linBottom", ;
		Top = 125, ;
		Width = 450
		*< END OBJECT: BaseClass="line" />

	ADD OBJECT 'Line1' AS line WITH ;
		BorderColor = 234,234,234, ;
		Height = 0, ;
		Left = 0, ;
		Name = "Line1", ;
		Top = 126, ;
		Width = 450
		*< END OBJECT: BaseClass="line" />

	ADD OBJECT 'Line2' AS line WITH ;
		BorderColor = 238,238,238, ;
		Height = 0, ;
		Left = 0, ;
		Name = "Line2", ;
		Top = 127, ;
		Width = 450
		*< END OBJECT: BaseClass="line" />

	ADD OBJECT 'Line3' AS line WITH ;
		BorderColor = 243,243,243, ;
		Height = 0, ;
		Left = 0, ;
		Name = "Line3", ;
		Top = 128, ;
		Width = 450
		*< END OBJECT: BaseClass="line" />

	ADD OBJECT 'Line4' AS line WITH ;
		BorderColor = 247,247,247, ;
		Height = 0, ;
		Left = 0, ;
		Name = "Line4", ;
		Top = 129, ;
		Width = 450
		*< END OBJECT: BaseClass="line" />

	ADD OBJECT 'Line5' AS line WITH ;
		BorderColor = 251,251,251, ;
		Height = 0, ;
		Left = 0, ;
		Name = "Line5", ;
		Top = 130, ;
		Width = 450
		*< END OBJECT: BaseClass="line" />
	
	PROCEDURE addtab		&& Adds a tab to the ribbon
		*==============================================================================
		* Method:			AddTab
		* Status:			Public
		* Purpose:			Adds a tab to the ribbon
		* Author:			Doug Hennig
		* Last Revision:	12/22/2020
		* Parameters:		tcName    - the name of the tab (optional: if it isn't
		*						specified, Tab<n> is used
		*					tcClass   - the class for the tab (optional: if it isn't
		*						specified, the class in This.TabClass is used)
		*					tcLibrary - the library for the tab class (optional: if it
		*						isn't specified, the library in This.TabLibrary is
		*						used)
		* Returns:			a reference to the new tab
		* Environment in:	none
		* Environment out:	a tab was added
		*==============================================================================
		
		lparameters tcName, ;
			tcClass, ;
			tcLibrary
		local lcName, ;
			lcClass, ;
			lcLibrary
		
		* Use defaults if the parameters weren't specified.
		
		lcName    = evl(tcName,    'Tab' + transform(This.ControlCount))
		lcClass   = evl(tcClass,   This.TabClass)
		lcLibrary = evl(tcLibrary, This.TabLibrary)
		
		* Have AddControl do the work.
		
		return This.AddControl(lcName, lcClass, lcLibrary)
		
	ENDPROC

	PROCEDURE adjusttabs		&& Adjusts the tabs so they align properly
		*==============================================================================
		* Method:			AdjustTabs
		* Status:			Public
		* Purpose:			Adjusts the tabs so they align properly
		* Author:			Doug Hennig
		* Last Revision:	12/22/2020
		* Parameters:		none
		* Returns:			none
		* Environment in:	none
		* Environment out:	the position of the tabs were adjusted
		*==============================================================================
		
		local loTabs, ;
			lnI, ;
			loControl, ;
			loPrevTab
		This.Controls[1].Left = 0
		loTabs = This.GetTabs()
		for lnI = 2 to loTabs.Count
			loControl = loTabs.Item(lnI)
			if pemstatus(loControl, 'Type', 5) and loControl.Type = 'Tab'
				loPrevTab      = loTabs.Item(lnI - 1)
				loControl.Left = loPrevTab.Left + loPrevTab.Width
			endif pemstatus(loControl, 'Type', 5) ...
		next lnI
		
	ENDPROC

	PROCEDURE Destroy
		* Nuke member objects.
		
		dodefault()
		This.Themes = NULL
		
	ENDPROC

	PROCEDURE gettabs		&& Returns a collection of tabs
		*==============================================================================
		* Method:			GetTabs
		* Status:			Public
		* Purpose:			Returns a collection of tabs
		* Author:			Doug Hennig
		* Last Revision:	12/22/2020
		* Parameters:		none
		* Returns:			a collection of tabs
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		local loTabs, ;
			loControl
		loTabs = createobject('Collection')
		for each loControl in This.Controls foxobject
			if pemstatus(loControl, 'Type', 5) and loControl.Type = 'Tab'
				loTabs.Add(loControl)
			endif pemstatus(loControl, 'Type', 5) ...
		next lnI
		return loTabs
		
	ENDPROC

	PROCEDURE Init
		local lnI, ;
			lcTheme
		
		* Match our width to the form.
		
		This.Width  = Thisform.Width
		This.Anchor = 10
		dodefault()
		
		* Create a collection of theme names.
		
		This.Themes = createobject('Collection')
		if empty(This.cThemes)
			This.Themes.Add('Colorful')
		else
			for lnI = 1 to occurs('<theme name=', This.cThemes)
				lcTheme = strextract(This.cThemes, '<theme name="', '"', lnI, 1)
				This.Themes.Add(lcTheme)
			next lnI
		endif empty(This.cThemes)
		
	ENDPROC

	PROCEDURE selecttab		&& Fired when the specified tab is selected
		*==============================================================================
		* Method:			SelectTab
		* Status:			Public
		* Purpose:			Fired when the specified tab is selected
		* Author:			Doug Hennig
		* Last revision:	12/26/2020
		* Parameters:		toTab - the reference to the selected tab
		* Returns:			.T.
		* Environment in:	cSelectedTab contains the name of the formerly selected tab
		* Environment out:	the toolbar for the formerly selected tab is hidden
		*					the Selected property for the formerly selected tab is set
		*						to .F.
		*					cSelectedTab contains the name of the selected tab
		*==============================================================================
		
		* When a tab is selected, deselect the currently selected tab and hide its
		* toolbar.
		
		lparameters toTab
		local lcOldTab, ;
			lcOldToolbar, ;
			loOldToolbar, ;
			loControl, ;
			loParent
		lcOldTab = This.cSelectedTab
		if not empty(lcOldTab)
			This.&lcOldTab..Selected = .F.
			lcOldToolbar = lcOldTab + 'Toolbar'
			if type('This.' + lcOldToolbar + '.Name') = 'C'
				loOldToolbar = This.&lcOldToolbar
				loOldToolbar.Visible = .F.
		
		* If one of the controls in the toolbar has focus, hide it or else it'll still
		* be visible.
		
				if type('Thisform.ActiveControl.Name') = 'C' and ;
					pemstatus(Thisform.ActiveControl, 'Visible', 5)
					loControl = Thisform.ActiveControl
					loParent  = loControl.Parent
					do while vartype(loParent) = 'O' and loParent <> loOldToolbar and ;
						loParent <> Thisform
						loParent = loParent.Parent
					enddo while vartype(loParent) = 'O' ...
					if vartype(loParent) = 'O' and loParent = loOldToolbar
						loControl.Visible = .F.
					endif vartype(loParent) = 'O' ...
				endif type('Thisform.ActiveControl.Name') = 'C'
			endif type('This.' + lcOldToolbar + '.Name') = 'C'
		endif not empty(lcOldTab)
		This.cSelectedTab = toTab.Name
		
	ENDPROC

	PROCEDURE theme_assign
		lparameters tcTheme
		dodefault(tcTheme)
		if not empty(This.cThemeColors)
			This.BackColor             = This.GetThemeColor('ribbonbackcolor')
			This.linBottom.BorderColor = This.GetThemeColor('ribbonbordercolor')
			This.Line1.BorderColor     = This.GetThemeColor('ribbonshadowcolor1')
			This.Line2.BorderColor     = This.GetThemeColor('ribbonshadowcolor2')
			This.Line3.BorderColor     = This.GetThemeColor('ribbonshadowcolor3')
			This.Line4.BorderColor     = This.GetThemeColor('ribbonshadowcolor4')
			This.Line5.BorderColor     = This.GetThemeColor('ribbonshadowcolor5')
		endif not empty(This.cThemeColors)
		
	ENDPROC

	PROCEDURE width_assign
		lparameters tnWidth
		This.Width = tnWidth
		store tnWidth to This.linBottom.Width, This.Line1.Width, This.Line2.Width, ;
			This.Line3.Width, This.Line4.Width, This.Line5.Width
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfribbonbase AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: addbar		&& Adds a bar to the dropdown menu
		*m: addcontrol		&& Adds a control to the container
		*m: enabled_assign
		*m: getcolor		&& Gets the value of the specified color
		*m: getthemecolor		&& Gets the specified color for the current theme
		*m: padding_assign
		*m: showmenu		&& Displays a shortcut menu
		*m: theme_assign
		*p: controltype		&& The type of control this contains
		*p: cthemecolors		&& The colors for the current theme
		*p: cthemes		&& The XML defining the themes
		*p: menu		&& A reference to an SFRibbonMenu object
		*p: ogdi		&& A reference to an SFGDIMeasureString object
		*p: padding		&& The space between the left edge and the first control
		*p: theme		&& The theme to use
		*p: type		&& The type of control this is
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED cthemecolors,cthemes,ogdi
	BorderWidth = 0
	controltype = 		&& The type of control this contains
	cthemecolors = 		&& The colors for the current theme
	cthemes = 		&& The XML defining the themes
	Enabled = .T.
	Height = 65
	menu = .NULL.		&& A reference to an SFRibbonMenu object
	Name = "sfribbonbase"
	ogdi = .NULL.		&& A reference to an SFGDIMeasureString object
	padding = 0		&& The space between the left edge and the first control
	theme = Colorful		&& The theme to use
	type = 		&& The type of control this is
	Width = 100
	_memberdata = <VFPData>
		<memberdata name="showmenu" display="ShowMenu"/>
		<memberdata name="ogdi" display="oGDI"/>
		<memberdata name="controltype" display="ControlType"/>
		<memberdata name="padding" display="Padding"/>
		<memberdata name="getcolor" display="GetColor"/>
		<memberdata name="padding_assign" display="Padding_Assign"/>
		<memberdata name="type" display="Type"/>
		<memberdata name="menu" display="Menu"/>
		<memberdata name="enabled" display="Enabled"/>
		<memberdata name="enabled_assign" display="Enabled_Assign"/>
		<memberdata name="theme" display="Theme"/>
		<memberdata name="theme_assign" display="Theme_Assign"/>
		<memberdata name="addcontrol" display="AddControl"/>
		<memberdata name="getthemecolor" display="GetThemeColor"/>
		<memberdata name="cthemes" display="cThemes"/>
		<memberdata name="cthemecolors" display="cThemeColors"/>
		<memberdata name="addbar" display="AddBar"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE addbar		&& Adds a bar to the dropdown menu
		*==============================================================================
		* Method:			AddBar
		* Status:			Public
		* Purpose:			Adds a bar to the dropdown menu
		* Author:			Doug Hennig
		* Last Revision:	12/27/2020
		* Parameters:		tcPrompt  - the prompt for the bar
		*					tcCommand - the command to execute
		*					tcImage   - the image for the bar
		*					tcEnabled - the expression that enables the bar (optional)
		* Returns:			a reference to the new bar
		* Environment in:	This.Menu contains an SFRibbonMenu object
		* Environment out:	a bar was added to the menu
		*==============================================================================
		
		lparameters tcPrompt, ;
			tcCommand, ;
			tcImage, ;
			tcEnabled
		local loBar
		loBar = This.Menu.AddBar(tcPrompt, tcCommand, tcImage, tcEnabled)
		return loBar
		
	ENDPROC

	PROCEDURE addcontrol		&& Adds a control to the container
		*==============================================================================
		* Method:			AddControl
		* Status:			Protected
		* Purpose:			Adds a control to the container
		* Author:			Doug Hennig
		* Last Revision:	12/22/2020
		* Parameters:		tcName    - the name of the control
		*					tcClass   - the class for the control
		*					tcLibrary - the library for the control
		* Returns:			a reference to the new control
		* Environment in:	none
		* Environment out:	a control was added
		*==============================================================================
		
		lparameters tcName, ;
			tcClass, ;
			tcLibrary
		local lnLeft, ;
			loControl
		
		* Figure out what position to use.
		
		lnLeft = 0
		for each loControl in This.Controls foxobject
			if pemstatus(loControl, 'Type', 5) and loControl.Type = This.ControlType
				lnLeft = max(lnLeft, loControl.Left + loControl.Width)
			endif pemstatus(loControl, 'Type', 5) ...
		next loControl
		
		* Add the control and set its properties.
		
		This.NewObject(tcName, tcClass, tcLibrary)
		loControl = This.&tcName
		with loControl
			.Left    = max(lnLeft, This.Padding)
			.Visible = .T.
		endwith
		return loControl
		
	ENDPROC

	PROCEDURE Destroy
		* Nuke member objects.
		
		This.Menu  = NULL
		This.oGDI  = NULL
		loThisform = NULL
		
	ENDPROC

	PROCEDURE enabled_assign
		lparameters tlEnabled
		This.Enabled = tlEnabled
		This.SetAll('Enabled', tlEnabled)
		
	ENDPROC

	PROCEDURE getcolor		&& Gets the value of the specified color
		*==============================================================================
		* Method:			GetColor
		* Status:			Public
		* Purpose:			Gets the value of the specified color
		* Author:			Doug Hennig
		* Last Revision:	12/25/2020
		* Parameters:		tuColor - the color as a string (e.g. "255,255,255" or
		*						"RGB(255, 255, 255)") or a numeric RGB value
		* Returns:			the color as an RGB value
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tuColor
		local lnColor
		do case
			case vartype(tuColor) = 'N'
				lnColor = tuColor
			case not ',' $ tuColor
				lnColor = val(tuColor)
			case upper(left(tuColor, 4)) = 'RGB('
				lnColor = evaluate(tuColor)
			otherwise
				lnColor = evaluate('RGB(' + tuColor + ')')
		endcase
		return lnColor
		
	ENDPROC

	PROTECTED PROCEDURE getthemecolor		&& Gets the specified color for the current theme
		*==============================================================================
		* Method:			GetThemeColor
		* Status:			Protected
		* Purpose:			Gets the specified color for the current theme
		* Author:			Doug Hennig
		* Last Revision:	12/25/2020
		* Parameters:		tcColorName - the name of the color to get
		* Returns:			the numeric color value for the specified color
		* Environment in:	This.cThemeColors contains the colors for the current theme
		* Environment out:	none
		*==============================================================================
		
		lparameters tcColorName
		local lcColor, ;
			lnColor
		lcColor = strextract(This.cThemeColors, tcColorName + '="', '"')
		lnColor = This.GetColor(lcColor)
		return lnColor
		
	ENDPROC

	PROCEDURE Init
		* Instantiate an SFGDIMeasureString object.
		
		This.oGDI = newobject('SFGDIMeasureString', 'SFGDIMeasureString.prg')
		
		* Instantiate an SFRibbonMenu object.
		
		This.Menu = newobject('SFRibbonMenu', 'SFRibbon.vcx')
		
		* Read in the theme colors.
		
		if file('RibbonThemes.xml')
			This.cThemes = filetostr('RibbonThemes.xml')
			This.Theme   = This.Theme
		endif file('RibbonThemes.xml')
		
	ENDPROC

	PROCEDURE padding_assign
		lparameters tnPadding
		This.Padding = tnPadding
		
	ENDPROC

	PROCEDURE RightClick
		* Display a right-click menu.
		
		This.ShowMenu()
		
	ENDPROC

	PROCEDURE showmenu		&& Displays a shortcut menu
		*==============================================================================
		* Method:			ShowMenu
		* Status:			Public
		* Purpose:			Displays a shortcut menu
		* Author:			Doug Hennig
		* Last revision:	01/06/2021
		* Parameters:		tnRow - the row for the menu (optional: if it isn't
		*						specified, the mouse position is used)
		*					tnCol - the column for the menu (optional: if it isn't
		*						specified, the mouse position is used)
		* Returns:			.T.
		* Environment in:	This.Menu contains a reference to the menu
		* Environment out:	a menu was displayed if it has any bars
		*==============================================================================
		
		lparameters tnRow, ;
			tnCol
		local lnRow, ;
			lnCol
		
		* If the menu is visible, close it.
		
		if This.Menu.Visible
			This.Menu.HideMenu()
			release loThisform
			return
		endif This.Menu.Visible
		
		* Put a reference to the form into a variable so we can access it in the
		* menu.
		
		if type('loThisform.Name') <> 'C'
			public loThisform
			loThisform = Thisform
		endif type('loThisform.Name') <> 'C'
		
		* Get the row and column to use.
		
		if pcount() = 0
			lnRow = mrow(0, 3) + Thisform.Top + sysmetric(9) + sysmetric(4) + ;
				iif(_screen.Visible, sysmetric(9) + sysmetric(20), 0)
			lnCol = mcol(0, 3) + Thisform.Left + sysmetric(3)
		else
			lnRow = tnRow
			lnCol = tnCol
		endif pcount() = 0
		
		* Display the menu if there are any bars.
		
		if This.Menu.Count > 0
			This.Menu.ShowMenu(lnRow, lnCol, This.Name)
		endif This.Menu.Count > 0
		
	ENDPROC

	PROCEDURE theme_assign
		lparameters tcTheme
		local lcColors
		lcColors = strextract(This.cThemes, '<theme name="' + tcTheme + '"', ;
			'/>', 1, 1)
		if not empty(lcColors)
			This.Theme        = tcTheme
			This.cThemeColors = lcColors
			This.SetAll('Theme', tcTheme)
			This.Menu.Theme = tcTheme
		endif not empty(lcColors)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfribbonmenu AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: addbar		&& Adds a bar to the menu
		*m: clear		&& Clears the menu
		*m: hidemenu		&& Hides the menu
		*m: showmenu		&& Displays the menu
		*m: visible_access
		*p: count		&& The number of bars in the menu
		*p: oform		&& A reference to an SFRibbonMenuForm object
		*p: padding		&& The spacing to use around bars
		*p: theme		&& The theme to use
		*p: visible		&& .T. if the menu is visible
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED oform
	count = 0		&& The number of bars in the menu
	Name = "sfribbonmenu"
	oform = .NULL.		&& A reference to an SFRibbonMenuForm object
	padding = 2		&& The spacing to use around bars
	theme = Default		&& The theme to use
	visible = .F.		&& .T. if the menu is visible
	Width = 17
	_memberdata = <VFPData>
		<memberdata name="addbar" display="AddBar"/>
		<memberdata name="abars[1]" display="aBars[1]"/>
		<memberdata name="showmenu" display="ShowMenu"/>
		<memberdata name="oform" display="oForm"/>
		<memberdata name="count" display="Count"/>
		<memberdata name="padding" display="Padding"/>
		<memberdata name="visible" display="Visible"/>
		<memberdata name="visible_access" display="Visible_Access"/>
		<memberdata name="theme" display="Theme"/>
		<memberdata name="hidemenu" display="HideMenu"/>
		<memberdata name="clear" display="Clear"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE addbar		&& Adds a bar to the menu
		*==============================================================================
		* Method:			AddBar
		* Status:			Public
		* Purpose:			Adds a bar to the menu
		* Author:			Doug Hennig
		* Last Revision:	12/27/2020
		* Parameters:		tcPrompt  - the prompt for the bar
		*					tcCommand - the command to execute
		*					tcImage   - the image for the bar
		*					tcEnabled - the expression that enables the bar (optional)
		* Returns:			a reference to the new bar
		* Environment in:	none
		* Environment out:	This.oForm contains a reference to an SFRibbonMenuForm
		*						object
		*					a bar was added to the form and Count was incremented
		*==============================================================================
		
		lparameters tcPrompt, ;
			tcCommand, ;
			tcImage, ;
			tcEnabled
		local lcName, ;
			loBar, ;
			lcImage
		
		* Create the menu form if it doesn't already exist.
		
		if vartype(This.oForm) <> 'O'
			This.oForm  = newobject('SFRibbonMenuForm', 'SFRibbon.vcx')
		endif vartype(This.oForm) <> 'O'
		
		* Increment the count, assign a name to the bar, and add it to the form.
		
		This.Count = This.Count + 1
		lcName = 'Bar' + transform(This.Count)
		if empty(tcPrompt)
			This.oForm.NewObject(lcName, 'SFRibbonMenuSeparator', 'SFRibbon.vcx')
			loBar = This.oForm.&lcName
		else
			This.oForm.NewObject(lcName, 'SFRibbonMenuBar', 'SFRibbon.vcx')
			loBar = This.oForm.&lcName
			with loBar
				.Caption = tcPrompt
				.Command = strtran(evl(tcCommand, ''), 'Thisform', 'loThisform', -1, ;
					-1, 1)
					&& since the menu bar isn't in the form the ribbon is on,
					&& replace any reference to "Thisform" to a variable that contains
					&& a reference to the form
		* For some reason, Image_Assign is protected so do what that method does.
		*		.Image   = evl(tcImage, '')
				lcImage  = evl(tcImage, '')
				.imgButton.Picture = lcImage
				if not empty(lcImage) and file(lcImage)
					.imgButton.Visible = .T.
				endif not empty(lcImage) ...
				.EnabledExpression = strtran(evl(tcEnabled, ''), 'Thisform', ;
					'loThisform', -1, -1, 1)
					&& same reason to replace Thisform as above
			endwith
		endif empty(tcPrompt)
		loBar.Visible = .T.
		return loBar
		
	ENDPROC

	PROCEDURE clear		&& Clears the menu
		*==============================================================================
		* Method:			Clear
		* Status:			Public
		* Purpose:			Clears the menu
		* Author:			Doug Hennig
		* Last Revision:	01/18/2021
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	This.oForm is nulled and This.Count is set to 0
		*==============================================================================
		
		This.oForm = NULL
		This.Count = 0
		
	ENDPROC

	PROCEDURE Destroy
		* Nuke member objects.
		
		This.oForm = NULL
		
	ENDPROC

	PROCEDURE hidemenu		&& Hides the menu
		*==============================================================================
		* Method:			HideMenu
		* Status:			Public
		* Purpose:			Hides the menu
		* Author:			Doug Hennig
		* Last Revision:	12/27/2020
		* Parameters:		none
		* Returns:			none
		* Environment in:	This.oForm may contain a reference to the form displaying
		*						the menu
		* Environment out:	the form is hidden
		*==============================================================================
		
		if vartype(This.oForm) = 'O'
			This.oForm.Hide()
		endif vartype(This.oForm) = 'O'
		
	ENDPROC

	PROCEDURE showmenu		&& Displays the menu
		*==============================================================================
		* Method:			ShowMenu
		* Status:			Public
		* Purpose:			Displays the menu
		* Author:			Doug Hennig
		* Last Revision:	01/06/2021
		* Parameters:		tnRow  - the row for the menu
		*					tnCol  - the column for the menu
		*					tcName - the name of the object with the menu
		* Returns:			none
		* Environment in:	This.Count contains the number of bars
		*					This.oForm contains a reference to the menu form
		*					This.Padding contains the spacing to use for bars
		*					This.Theme contains the current theme
		* Environment out:	the menu form is displayed
		*==============================================================================
		
		lparameters tnRow, ;
			tnCol, ;
			tcName
		local loForm, ;
			lnTop, ;
			lnWidth, ;
			lnI, ;
			lcName
		
		* Set the position and theme for each bar and get the maximum width.
		
		loForm  = This.oForm
		lnTop   = This.Padding
		lnWidth = 0
		for lnI = 1 to This.Count
			lcName = 'Bar' + transform(lnI)
			with loForm.&lcName
				.Top    = lnTop
				.Left   = This.Padding
				.Theme  = This.Theme
				lnTop   = lnTop + .Height
				lnWidth = max(lnWidth, .Width)
				if .Type <> 'Separator' and not empty(.EnabledExpression)
					.Enabled = evaluate(.EnabledExpression)
				endif .Type <> 'Separator' ...
				if lnI = 1
					loForm.BackColor = .BackColor
				endif lnI = 1
			endwith
		next lnI
		
		* Set the widths of the bars and the form size and position.
		
		for lnI = 1 to This.Count
			lcName = 'Bar' + transform(lnI)
			loForm.&lcName..Width = lnWidth
		next lnI
		with loForm
			.Height     = lnTop   + This.Padding
			.Width      = lnWidth + This.Padding * 2
			.Top        = tnRow
			.Left       = tnCol
			.ObjectName = tcName
		endwith
		loForm.Show()
		
	ENDPROC

	PROCEDURE visible_access
		return vartype(This.oForm) = 'O' and This.oForm.Visible
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfribbonmenubar AS sfribbontoolbarbuttonhorizontal OF "sfribbon.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	BackColor = 255,255,255
	Name = "sfribbonmenubar"
	_memberdata = <VFPData>
		<memberdata name="enabledexpression" display="EnabledExpression"/>
		</VFPData>
	imgButton.Name = "imgButton"
	imgButton.Top = 5
	lblButton.Name = "lblButton"
	lblButton.Top = 5
	imgDown.Height = 9
	imgDown.Name = "imgDown"
	imgDown.Picture = sfribbonright.png
	imgDown.Top = 9
	imgDown.Width = 7
	
	PROCEDURE Click
		* Close the menu and do the usual behavior if we don't have a submenu. If we do
		* have a submenu, do nothing since there should be no behavior.
		
		if This.Menu.Count = 0
			This.Parent.Hide()
			dodefault()
			release loThisform
		endif This.Menu.Count = 0
		
	ENDPROC

	PROCEDURE MouseEnter
		lparameters tnButton, ;
			tnShift, ;
			tnXCoord, ;
			tnYCoord
		dodefault(tnButton, tnShift, tnXCoord, tnYCoord)
		
		* Display a submenu.
		
		if This.Menu.Count > 0
			This.ShowMenu()
		endif This.Menu.Count > 0
		
	ENDPROC

	PROCEDURE MouseLeave
		lparameters tnButton, ;
			tnShift, ;
			tnXCoord, ;
			tnYCoord
		dodefault(tnButton, tnShift, tnXCoord, tnYCoord)
		
		* Hide a submenu.
		
		if This.Menu.Count > 0
			This.Menu.HideMenu()
		endif This.Menu.Count > 0
		
	ENDPROC

	PROCEDURE showmenu		&& Displays the menu
		* Display the submenu beside ourselves.
		
		if not This.Menu.Visible
			SFRibbonBase::ShowMenu(Thisform.Top + This.Top, ;
				objtoclient(This, 2) + Thisform.Left + This.Width)
		endif not This.Menu.Visible
		
	ENDPROC

	PROCEDURE theme_assign
		lparameters tcTheme
		dodefault(tcTheme)
		store This.GetThemeColor('menuitembackcolor') to This.BackColor, This.nBackColor
		This.HighlightedColor = This.GetThemeColor('menuitemhighlightcolor')
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfribbonmenuform AS form 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="shpBorder" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="tmrClick" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: calculatewidth		&& Calculate the width
		*p: objectname		&& The name of the object that has the menu
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	AlwaysOnTop = .T.
	BackColor = 255,255,255
	BorderStyle = 0
	Caption = "sfribbonmenu"
	Desktop = .T.
	DoCreate = .T.
	Height = 68
	KeyPreview = .T.
	Left = 0
	Name = "sfribbonmenuform"
	objectname = 		&& The name of the object that has the menu
	ShowWindow = 2
	TitleBar = 0
	Top = 0
	Width = 136
	_memberdata = <VFPData>
		<memberdata name="calculatewidth" display="CalculateWidth"/>
		<memberdata name="objectname" display="ObjectName"/>
		</VFPData>		&& XML Metadata for customizable properties

	ADD OBJECT 'shpBorder' AS shape WITH ;
		BackStyle = 0, ;
		BorderColor = 200,198,196, ;
		Height = 50, ;
		Left = 0, ;
		Name = "shpBorder", ;
		Top = 0, ;
		Width = 120
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'tmrClick' AS timer WITH ;
		Enabled = .F., ;
		Height = 23, ;
		Interval = 30, ;
		Left = 60, ;
		Name = "tmrClick", ;
		Top = 10, ;
		Width = 23
		*< END OBJECT: BaseClass="timer" />
	
	PROCEDURE calculatewidth		&& Calculate the width
		* This is needed by SFRibbonMenuBar.
		
	ENDPROC

	PROCEDURE Hide
		* Disable the timer.
		
		This.tmrClick.Enabled = .F.
		
	ENDPROC

	PROCEDURE KeyPress
		* If the user presses the hotkey for a bar, execute that bar.
		
		lparameters tnKeyCode, ;
			tnShiftAltCtrl
		if tnShiftAltCtrl = 0
			lcHotKey = '\<' + upper(chr(tnKeyCode))
			for each loControl in This.Controls foxobject
				if pemstatus(loControl, 'Caption', 5) and ;
					lcHotKey $ upper(loControl.Caption)
					loControl.Click()
					exit
				endif pemstatus(loControl, 'Caption', 5) ...
			next loControl
		endif tnShiftAltCtrl = 0
		
	ENDPROC

	PROCEDURE Show
		lparameters tnStyle
		
		* Enable the timer that looks for mouse clicks.
		
		This.tmrClick.Enabled = .T.
		
		* Adjust the shape.
		
		This.shpBorder.Width  = This.Width
		This.shpBorder.Height = This.Height
		
	ENDPROC

	PROCEDURE tmrClick.Timer
		* If the user clicks outside the menu or moves the mouse outside the form,
		* close the menu.
		
		local llDown, ;
			laMouse[1], ;
			lnMouse, ;
			llMouseOutsideForm, ;
			lcObjectName, ;
			llClickOutsideMenu
		#define VK_LBUTTON 0x01
		declare integer GetAsyncKeyState in user32 integer vKey
		llDown             = GetAsyncKeyState(VK_LBUTTON) > 0 or mdown()
			&& use GetAsyncKeyState because MDOWN() is .F. if click outside form
		lnMouse            = amouseobj(laMouse, 1)
		llMouseOutsideForm = lnMouse > 0 and laMouse[2].Name = 'Screen'
		lcObjectName       = iif(lnMouse > 0 and ;
			type('laMouse[1].Parent.Type') = 'C' and 'Button' $ laMouse[1].Parent.Type, ;
			laMouse[1].Parent.Name, laMouse[1].Name)
			&& if the user clicks a member of the button, use the button name
		llClickOutsideMenu = llDown and (lnMouse = 0 or (laMouse[2] <> Thisform and ;
			lcObjectName <> Thisform.ObjectName))
		if llMouseOutsideForm or llClickOutsideMenu
			This.Enabled        = .F.
			This.Parent.Visible = .F.
			release loThisform
		endif mdown() ...
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfribbonmenuseparator AS sfribbonbase OF "sfribbon.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="shpSeparator" UniqueID="" Timestamp="" />

	BackStyle = 0
	Height = 4
	Name = "sfribbonmenuseparator"
	type = Separator
	Width = 200

	ADD OBJECT 'shpSeparator' AS shape WITH ;
		Anchor = 10, ;
		BackStyle = 0, ;
		BorderColor = 225,223,221, ;
		BorderWidth = 0, ;
		FillColor = 225,223,221, ;
		FillStyle = 0, ;
		Height = 1, ;
		Left = 26, ;
		Name = "shpSeparator", ;
		Top = 2, ;
		Width = 174
		*< END OBJECT: BaseClass="shape" />
	
	PROCEDURE theme_assign
		lparameters tcTheme
		dodefault(tcTheme)
		store This.GetThemeColor('menuseparatorcolor') to This.shpSeparator.BorderColor, ;
			This.shpSeparator.FillColor
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfribbontab AS sfribbonbase OF "sfribbon.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="lblTab" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="linActive" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: addsection		&& Adds a section to the toolbar
		*m: calculatewidth		&& Calculates the width of the pad
		*m: caption_assign
		*m: selected_assign
		*m: toolbar_access
		*p: caption		&& The caption for the pad
		*p: highlightedcolor		&& The background color when the pad is highlighted
		*p: nbackcolor		&& The normal BackColor
		*p: selected		&& .T. if the pad is selected
		*p: toolbar		&& A reference to the toolbar for the pad
		*p: toolbarclass		&& The class for the toolbar displayed when this pad is selected
		*p: toolbarlibrary		&& The library for the toolbar displayed when this pad is selected
	*</DefinedPropArrayMethod>

	PROTECTED nbackcolor
	BackColor = 243,242,241
	BorderWidth = 0
	caption = 		&& The caption for the pad
	Height = 30
	highlightedcolor = 250,249,248		&& The background color when the pad is highlighted
	Name = "sfribbontab"
	nbackcolor = 0		&& The normal BackColor
	ogdi = .NULL.
	padding = 10
	selected = .F.		&& .T. if the pad is selected
	toolbar = .NULL.		&& A reference to the toolbar for the pad
	toolbarclass = SFRibbonToolbar		&& The class for the toolbar displayed when this pad is selected
	toolbarlibrary = SFRibbon.vcx		&& The library for the toolbar displayed when this pad is selected
	type = Tab
	Width = 65
	_memberdata = <VFPData>
		<memberdata name="calculatewidth" display="CalculateWidth"/>
		<memberdata name="caption_assign" display="Caption_Assign"/>
		<memberdata name="highlightedcolor" display="HighlightedColor"/>
		<memberdata name="highlightedcolor_assign" display="HighlightedColor_Assign"/>
		<memberdata name="nbackcolor" display="nBackColor"/>
		<memberdata name="padding" display="Padding"/>
		<memberdata name="padding_assign" display="Padding_Assign"/>
		<memberdata name="selected_assign" display="Selected_Assign"/>
		<memberdata name="caption" display="Caption"/>
		<memberdata name="getcolor" display="GetColor"/>
		<memberdata name="selected" display="Selected"/>
		<memberdata name="toolbar" display="Toolbar"/>
		<memberdata name="toolbar_access" display="Toolbar_Access"/>
		<memberdata name="toolbarclass" display="ToolbarClass"/>
		<memberdata name="toolbarlibrary" display="ToolbarLibrary"/>
		<memberdata name="type" display="Type"/>
		<memberdata name="ogdi" display="oGDI"/>
		<memberdata name="addsection" display="AddSection"/>
		</VFPData>

	ADD OBJECT 'lblTab' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Label1", ;
		FontName = "Segoe UI", ;
		FontSize = 10, ;
		Left = 10, ;
		Name = "lblTab", ;
		Top = 7
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'linActive' AS shape WITH ;
		BorderColor = 16,110,190, ;
		BorderWidth = 0, ;
		FillColor = 16,110,190, ;
		FillStyle = 0, ;
		Height = 3, ;
		Left = 0, ;
		Name = "linActive", ;
		Top = 27, ;
		Visible = .F., ;
		Width = 65
		*< END OBJECT: BaseClass="shape" />
	
	PROCEDURE addsection		&& Adds a section to the toolbar
		*==============================================================================
		* Method:			AddSection
		* Status:			Public
		* Purpose:			Adds a section to the toolbar
		* Author:			Doug Hennig
		* Last Revision:	12/24/2020
		* Parameters:		tcName    - the name of the section (optional: if it isn't
		*						specified, Section<n> is used
		*					tcClass   - the class for the section (optional: if it
		*						isn't specified, the class in This.SectionClass is
		*						used)
		*					tcLibrary - the library for the section class (optional: if
		*						it isn't specified, the library in This.SectionLibrary
		*						is used)
		* Returns:			a reference to the new section
		* Environment in:	none
		* Environment out:	a section was added
		* Note:				this is just a helper method to make it easier to add a
		*						section, since the toolbar does all the work
		*==============================================================================
		
		lparameters tcName, ;
			tcClass, ;
			tcLibrary
		return This.Toolbar.AddSection(tcName, tcClass, tcLibrary)
		
	ENDPROC

	PROCEDURE calculatewidth		&& Calculates the width of the pad
		*==============================================================================
		* Method:			CalculateWidth
		* Status:			Public
		* Purpose:			Calculates the width of the tab
		* Author:			Doug Hennig
		* Last Revision:	12/22/2020
		* Parameters:		none
		* Returns:			none
		* Environment in:	Padding contains the desired space
		* Environment out:	the width of the container has been updated
		*					the position of the other tabs in the ribbon have been
		*						adjusted
		*==============================================================================
		
		local lnWidth
		lnWidth = This.oGDI.GetWidth(This.lblTab.Caption) + 2 * This.Padding
			&& This.lblTab.Width is inaccurate if the form isn't visible yet
		if This.Width <> lnWidth
			This.Width = lnWidth
			This.Parent.AdjustTabs()
		endif This.Width <> lnWidth
		
	ENDPROC

	PROCEDURE caption_assign
		lparameters tcCaption
		store tcCaption to This.Caption, This.lblTab.Caption
		This.CalculateWidth()
		
	ENDPROC

	PROCEDURE Click
		This.Selected = .T.
		
	ENDPROC

	PROCEDURE Destroy
		* Nuke member objects.
		
		This.Toolbar = NULL
		
	ENDPROC

	PROCEDURE Init
		dodefault()
		
		* Set the font for the SFGDIMeasureString object.
		
		This.oGDI.SetFont(This.lblTab.FontName, This.lblTab.FontSize)
		
		* Set Caption to itself so the width is calculated.
		
		if not empty(This.Caption)
			This.Caption = This.Caption
		endif not empty(This.Caption)
		
	ENDPROC

	PROCEDURE MouseEnter
		* When the user hovers the mouse over the tab, make the label bold and the line
		* full width (if it's visible).
		
		lparameters tnButton, ;
			tnShift, ;
			tnXCoord, ;
			tnYCoord
		This.nBackColor      = This.BackColor
		This.BackColor       = This.GetColor(This.HighlightedColor)
		This.lblTab.FontBold = .T.
		if This.linActive.Visible
			This.linActive.Left  = 0
			This.linActive.Width = This.Width
		endif This.linActive.Visible
		
	ENDPROC

	PROCEDURE MouseLeave
		* When the user moves the mouse outside the tab, make the label normal and the
		* line the width of the label (if it's visible).
		
		lparameters tnButton, ;
			tnShift, ;
			tnXCoord, ;
			tnYCoord
		This.BackColor       = This.nBackColor
		This.lblTab.FontBold = This.Selected
		if This.linActive.Visible
			This.linActive.Left  = This.lblTab.Left
			This.linActive.Width = This.lblTab.Width
		endif This.linActive.Visible
		
	ENDPROC

	PROCEDURE padding_assign
		lparameters tnPadding
		dodefault(tnPadding)
		This.CalculateWidth()
		
	ENDPROC

	PROCEDURE selected_assign
		* When we're selected, tell the ribbon that we are, make the label bold, our
		* toolbar visible, and the line visible and full width. When we aren't
		* selected, make the label normal and hide the line and toolbar.
		
		lparameters tlSelected
		local loControl, ;
			loParent
		This.Selected = tlSelected
		if This.Selected
			This.Parent.SelectTab(This)
			This.lblTab.FontBold   = .T.
			This.linActive.Visible = .T.
			This.Toolbar.Visible   = .T.
			This.linActive.Left    = 0
			This.linActive.Width   = This.Width
		
		* If one of the controls in the toolbar has focus and it isn't visible because
		* SFRibbon.SelectTab hid it, make it visible again.
		
			if type('Thisform.ActiveControl.Name') = 'C' and ;
				pemstatus(Thisform.ActiveControl, 'Visible', 5) and ;
				not Thisform.ActiveControl.Visible
				loControl = Thisform.ActiveControl
				loParent  = loControl.Parent
				do while vartype(loParent) = 'O' and loParent <> This.Toolbar and ;
					loParent <> Thisform
					loParent = loParent.Parent
				enddo while vartype(loParent) = 'O' ...
				if vartype(loParent) = 'O' and loParent = This.Toolbar
					loControl.Visible = .T.
				endif vartype(loParent) = 'O' ...
			endif type('Thisform.ActiveControl.Name') = 'C' ...
		else
			This.lblTab.FontBold   = .F.
			This.linActive.Visible = .F.
			This.Toolbar.Visible   = .F.
		endif This.Selected
		
	ENDPROC

	PROCEDURE theme_assign
		lparameters tcTheme
		dodefault(tcTheme)
		This.BackColor        = This.GetThemeColor('ribbonbackcolor')
		This.HighlightedColor = This.GetThemeColor('tabhighlightcolor')
		store This.GetThemeColor('tabbordercolor') to This.linActive.BorderColor, ;
			This.linActive.FillColor
		
	ENDPROC

	PROCEDURE toolbar_access
		* The first time the Toolbar property is accessed, instantiate the desired
		* class.
		
		local lcToolbarName
		if vartype('This.Toolbar') <> 'O'
			lcToolbarName = This.Name + 'Toolbar'
			if type('This.Parent.' + lcToolbarName + '.Name') <> 'C'
				This.Parent.NewObject(lcToolbarName, This.ToolbarClass, ;
					This.ToolbarLibrary)
				This.Parent.&lcToolbarName..Top = This.Height
			endif type('This.Parent.' + lcToolbarName + '.Name') <> 'C'
			This.Toolbar = This.Parent.&lcToolbarName
		endif vartype('This.Toolbar') <> 'O'
		return This.Toolbar
		
	ENDPROC

	PROCEDURE lblTab.Click
		This.Parent.Click()
		
	ENDPROC

	PROCEDURE linActive.Click
		This.Parent.Click()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfribbontoolbar AS sfribbonbase OF "sfribbon.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: addsection		&& Adds a section to the toolbar
		*m: adjustsections		&& Adjusts the location of sections when the width of one changes
		*p: sectionclass		&& The default section class
		*p: sectionlibrary		&& The default section library
	*</DefinedPropArrayMethod>

	BackStyle = 0
	controltype = Section
	Height = 95
	Name = "sfribbontoolbar"
	sectionclass = SFRibbonToolbarSection		&& The default section class
	sectionlibrary = SFRibbon.vcx		&& The default section library
	type = Toolbar
	_memberdata = <VFPData>
		<memberdata name="type" display="Type"/>
		<memberdata name="addsection" display="AddSection"/>
		<memberdata name="sectionclass" display="SectionClass"/>
		<memberdata name="sectionlibrary" display="SectionLibrary"/>
		<memberdata name="adjustsections" display="AdjustSections"/>
		</VFPData>
	
	PROCEDURE addsection		&& Adds a section to the toolbar
		*==============================================================================
		* Method:			AddSection
		* Status:			Public
		* Purpose:			Adds a section to the toolbar
		* Author:			Doug Hennig
		* Last Revision:	12/22/2020
		* Parameters:		tcName    - the name of the section (optional: if it isn't
		*						specified, Section<n> is used
		*					tcClass   - the class for the section (optional: if it
		*						isn't specified, the class in This.SectionClass is
		*						used)
		*					tcLibrary - the library for the section class (optional: if
		*						it isn't specified, the library in This.SectionLibrary
		*						is used)
		* Returns:			a reference to the new section
		* Environment in:	none
		* Environment out:	a section was added
		*==============================================================================
		
		lparameters tcName, ;
			tcClass, ;
			tcLibrary
		local lcName, ;
			lcClass, ;
			lcLibrary
		
		* Use defaults if the class and library weren't specified.
		
		lcName    = evl(tcName,    'Section' + transform(This.ControlCount))
		lcClass   = evl(tcClass,   This.SectionClass)
		lcLibrary = evl(tcLibrary, This.SectionLibrary)
		
		* Have AddControl do the work.
		
		return This.AddControl(lcName, lcClass, lcLibrary)
		
	ENDPROC

	PROCEDURE adjustsections		&& Adjusts the location of sections when the width of one changes
		*==============================================================================
		* Method:			AdjustSections
		* Status:			Public
		* Purpose:			Adjusts the location of sections when the width of one
		*						changes
		* Author:			Doug Hennig
		* Last Revision:	02/11/2021
		* Parameters:		none
		* Returns:			none
		* Environment in:	the toolbar contains sections
		* Environment out:	the sections have been adjusted so they abut each other and
		*						the toolbar width has been updated
		*==============================================================================
		
		local lnLeft, ;
			loControl
		lnLeft = 0
		for each loControl in This.Controls foxobject
			loControl.Left = lnLeft
			lnLeft = loControl.Left + loControl.Width
		next loControl
		This.Width = lnLeft + 1
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfribbontoolbarbutton AS sfribbonbase OF "sfribbon.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="imgButton" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblButton" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="imgDown" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: calculatewidth		&& Calculates the width of the button
		*m: caption_assign
		*m: image_assign
		*m: tooltiptext_assign
		*m: visible_assign
		*m: wordwrap_assign
		*p: caption		&& The caption for the button label
		*p: command		&& The command to execute when the button is clicked
		*p: disabledimage		&& The disabled image for the button
		*p: enabledexpression		&& An expression that determines if the button is enabled
		*p: highlightedcolor		&& The color when the button is highlighted
		*p: image		&& The image for the button
		*p: nbackcolor		&& The normal backcolor
		*p: nlines		&& The number of lines in the label
		*p: wordwrap		&& .T. to auto-wrap the caption for the button; .F. to size the button for the caption
	*</DefinedPropArrayMethod>

	PROTECTED nbackcolor,nlines
	BackColor = 243,242,241
	caption = 		&& The caption for the button label
	command = 		&& The command to execute when the button is clicked
	disabledimage = 		&& The disabled image for the button
	enabledexpression = 		&& An expression that determines if the button is enabled
	Height = 72
	highlightedcolor = 200,198,196		&& The color when the button is highlighted
	image = 		&& The image for the button
	Name = "sfribbontoolbarbutton"
	nbackcolor = 0		&& The normal backcolor
	nlines = 0		&& The number of lines in the label
	padding = 8
	ToolTipText = ""
	type = Button
	Visible = .T.
	Width = 72
	wordwrap = .F.		&& .T. to auto-wrap the caption for the button; .F. to size the button for the caption
	_memberdata = <VFPData>
		<memberdata name="highlightedcolor" display="HighlightedColor"/>
		<memberdata name="nbackcolor" display="nBackColor"/>
		<memberdata name="caption" display="Caption"/>
		<memberdata name="caption_assign" display="Caption_Assign"/>
		<memberdata name="image" display="Image"/>
		<memberdata name="image_assign" display="Image_Assign"/>
		<memberdata name="getcolor" display="GetColor"/>
		<memberdata name="command" display="Command"/>
		<memberdata name="type" display="Type"/>
		<memberdata name="calculatewidth" display="CalculateWidth"/>
		<memberdata name="ogdi" display="oGDI"/>
		<memberdata name="padding" display="Padding"/>
		<memberdata name="addbar" display="AddBar"/>
		<memberdata name="nlines" display="nLines"/>
		<memberdata name="enabledexpression" display="EnabledExpression"/>
		<memberdata name="wordwrap" display="WordWrap"/>
		<memberdata name="wordwrap_assign" display="WordWrap_Assign"/>
		<memberdata name="visible" display="Visible"/>
		<memberdata name="visible_assign" display="Visible_Assign"/>
		<memberdata name="disabledimage" display="DisabledImage"/>
		<memberdata name="tooltiptext" display="ToolTipText"/>
		<memberdata name="tooltiptext_assign" display="ToolTipText_Assign"/>
		</VFPData>

	ADD OBJECT 'imgButton' AS image WITH ;
		BackStyle = 0, ;
		Height = 32, ;
		Left = 20, ;
		Name = "imgButton", ;
		Stretch = 1, ;
		Top = 5, ;
		Visible = .F., ;
		Width = 32, ;
		ZOrderSet = 0
		*< END OBJECT: BaseClass="image" />

	ADD OBJECT 'imgDown' AS image WITH ;
		Height = 3, ;
		Left = 59, ;
		Name = "imgDown", ;
		Picture = sfribbondown.png, ;
		Top = 34, ;
		Visible = .F., ;
		Width = 7, ;
		ZOrderSet = 2
		*< END OBJECT: BaseClass="image" />

	ADD OBJECT 'lblButton' AS label WITH ;
		Alignment = 2, ;
		AutoSize = .F., ;
		BackStyle = 0, ;
		Caption = "Label1", ;
		FontName = "Segoe UI", ;
		Height = 32, ;
		Left = 2, ;
		Name = "lblButton", ;
		Top = 39, ;
		Width = 68, ;
		WordWrap = .T., ;
		ZOrderSet = 1
		*< END OBJECT: BaseClass="label" />
	
	PROCEDURE addbar
		*==============================================================================
		* Method:			AddBar
		* Status:			Public
		* Purpose:			Adds a bar to the dropdown menu
		* Author:			Doug Hennig
		* Last Revision:	12/27/2020
		* Parameters:		tcPrompt  - the prompt for the bar
		*					tcCommand - the command to execute
		*					tcImage   - the image for the bar
		*					tcEnabled - the expression that enables the bar (optional)
		* Returns:			a reference to the new bar
		* Environment in:	This.Menu contains an SFRibbonMenu object
		* Environment out:	a bar was added to the menu
		*					the down button is visible
		*==============================================================================
		
		lparameters tcPrompt, ;
			tcCommand, ;
			tcImage, ;
			tcEnabled
		local loBar
		loBar = dodefault(tcPrompt, tcCommand, tcImage, tcEnabled)
		if not This.imgDown.Visible
			This.imgDown.Visible = .T.
			if This.nLines > 1 and right(This.Caption, 2) <> '  '
				This.Caption = This.Caption + '  '
			endif This.nLines > 1 ...
		endif not This.imgDown.Visible
		This.CalculateWidth()
		return loBar
		
	ENDPROC

	PROCEDURE calculatewidth		&& Calculates the width of the button
		*==============================================================================
		* Method:			CalculateWidth
		* Status:			Public
		* Purpose:			Calculates the width of the button
		* Author:			Doug Hennig
		* Last Revision:	01/07/2021
		* Parameters:		none
		* Returns:			none
		* Environment in:	Padding contains the desired space
		*					WordWrap is .T. to wrap the caption, .F. to size the button
		* Environment out:	the width of the button and its section may been updated
		*					the down button has been positioned properly
		*					This.nLines contains the number of lines for the label
		*==============================================================================
		
		local lnWidth
		if not empty(This.Caption)
			if This.WordWrap
				This.oGDI.SetSize(This.lblButton.Width, This.lblButton.Height)
			endif This.WordWrap
			This.oGDI.MeasureString(This.lblButton.Caption)
			lnWidth = max(ceiling(This.oGDI.nWidth) + 2 * This.lblButton.Left, ;
				This.imgButton.Width + 2 * This.Padding)
				&& use a width of the label or the image, whichever is wider
				&& This.lblButton.Width is inaccurate if the form isn't visible yet
			if This.Width <> lnWidth and not This.WordWrap
				This.Width = lnWidth
				This.lblButton.Width = This.Width - 2 * This.lblButton.Left
			endif This.Width <> lnWidth ...
			This.imgButton.Left  = int((This.Width - This.imgButton.Width)/2)
				&& center the image
		
		* If there's one line of text, center the down button below the label.
		
			if This.oGDI.nLines = 1
				This.imgDown.Left = int((This.Width - This.imgDown.Width)/2)
				This.imgDown.Top  = This.lblButton.Top  + 24
			else
				This.imgDown.Left = This.lblButton.Left + This.lblButton.Width  - 5
				This.imgDown.Top  = This.lblButton.Top  + This.lblButton.Height - 10
			endif This.oGDI.nLines = 1
			This.nLines = This.oGDI.nLines
			This.Parent.CalculateWidth()
		endif not empty(This.Caption)
		
	ENDPROC

	PROCEDURE caption_assign
		lparameters tcCaption
		store tcCaption to This.Caption, This.lblButton.Caption
		This.CalculateWidth()
		
	ENDPROC

	PROCEDURE Click
		* Execute the command if we have one or display the menu if not. Note that
		* references to Thisform have to be changed to an object reference because
		* EXECSCRIPT executes outside the object mechanism.
		
		local lcCommand
		do case
			case not empty(This.Command)
				lcCommand  = This.Command
				if type('loThisform') <> 'O'
					private loThisform
					loThisform = Thisform
				endif type('loThisform') <> 'O'
				if atc('loThisform', lcCommand) = 0
					lcCommand = strtran(lcCommand, 'Thisform', 'loThisform', -1, -1, 1)
				endif atc('loThisform', lcCommand) = 0
				execscript(lcCommand)
			case This.Menu.Count > 0
				This.ShowMenu()
			otherwise
				messagebox('Not implemented')
		endcase
		
	ENDPROC

	PROCEDURE enabled_assign
		lparameters tlEnabled
		do case
			case tlEnabled and not empty(This.Image) and file(This.Image)
				This.imgButton.Picture = This.Image
			case not tlEnabled and not empty(This.DisabledImage) and ;
				file(This.DisabledImage)
				This.imgButton.Picture = This.DisabledImage
		endcase
		dodefault(tlEnabled)
		
	ENDPROC

	PROCEDURE image_assign
		lparameters tcImage
		store tcImage to This.Image, This.imgButton.Picture
		if not empty(tcImage) and file(tcImage)
			This.imgButton.Visible = .T.
		endif not empty(tcImage) ...
		
	ENDPROC

	PROCEDURE Init
		* Set the font for the SFGDIMeasureString object.
		
		dodefault()
		This.oGDI.SetFont(This.lblButton.FontName, This.lblButton.FontSize)
		
		* Save the background color.
		
		This.nBackColor = This.BackColor
		
	ENDPROC

	PROCEDURE MouseEnter
		* When the user hovers the mouse over the button, highlight it if it's enabled.
		
		lparameters tnButton, ;
			tnShift, ;
			tnXCoord, ;
			tnYCoord
		local loControl
		if This.Enabled
			This.BackColor = This.GetColor(This.HighlightedColor)
		endif This.Enabled
		
		* Ensure other buttons aren't highlighted. This normally happens in MouseLeave
		* for the buttons but dropdown menus can interfere with that.
		
		for each loControl in This.Parent.Controls foxobject
			if loControl.Name <> This.Name and pemstatus(loControl, 'MouseLeave', 5)
				loControl.MouseLeave()
			endif loControl.Name <> This.Name
		next loControl
		
	ENDPROC

	PROCEDURE MouseLeave
		* When the user moves the mouse outside the button, make it normal.
		
		lparameters tnButton, ;
			tnShift, ;
			tnXCoord, ;
			tnYCoord
		This.BackColor = This.nBackColor
		
	ENDPROC

	PROCEDURE padding_assign
		lparameters tnPadding
		dodefault(tnPadding)
		This.CalculateWidth()
		
	ENDPROC

	PROCEDURE Refresh
		* If we have an EnabledExpression expression, use it to determine if the button
		* is enabled.
		
		if not empty(This.EnabledExpression)
			This.Enabled = evaluate(This.EnabledExpression)
		endif not empty(This.EnabledExpression)
		
	ENDPROC

	PROCEDURE showmenu
		* Display the menu below ourselves.
		
		dodefault(objtoclient(This, 1) + This.Height + Thisform.Top + ;
				sysmetric(9) + sysmetric(4) + ;
				iif(Thisform.Desktop, 0, sysmetric(9) + sysmetric(20)), ;
			objtoclient(This, 2) + Thisform.Left + sysmetric(3))
		
	ENDPROC

	PROCEDURE theme_assign
		lparameters tcTheme
		dodefault(tcTheme)
		store This.GetThemeColor('ribbonbackcolor') to This.BackColor, This.nBackColor
		This.HighlightedColor = This.GetThemeColor('buttonhighlightcolor')
		
	ENDPROC

	PROCEDURE tooltiptext_assign
		lparameters tcValue
		This.ToolTipText = tcValue
		This.SetAll('ToolTipText', tcValue)
		
	ENDPROC

	PROCEDURE visible_assign
		lparameters tlVisible
		This.Visible = tlVisible
		This.Parent.CalculateWidth()
		
	ENDPROC

	PROCEDURE wordwrap_assign
		lparameters tlWordWrap
		This.WordWrap = tlWordWrap
		This.CalculateWidth()
		
	ENDPROC

	PROCEDURE imgButton.Click
		This.Parent.Click()
		
	ENDPROC

	PROCEDURE imgDown.Click
		This.Parent.Click()
		
	ENDPROC

	PROCEDURE lblButton.Click
		This.Parent.Click()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfribbontoolbarbuttonhorizontal AS sfribbontoolbarbutton OF "sfribbon.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	Height = 25
	Name = "sfribbontoolbarbuttonhorizontal"
	type = HButton
	Width = 100
	imgButton.Height = 16
	imgButton.Left = 5
	imgButton.Name = "imgButton"
	imgButton.Top = 5
	imgButton.Width = 16
	lblButton.Alignment = 0
	lblButton.AutoSize = .T.
	lblButton.Left = 30
	lblButton.Name = "lblButton"
	lblButton.Top = 5
	lblButton.WordWrap = .F.
	imgDown.Height = 3
	imgDown.Left = 85
	imgDown.Name = "imgDown"
	imgDown.Top = 10
	imgDown.Width = 7
	
	PROCEDURE calculatewidth		&& Calculates the width of the button
		*==============================================================================
		* Method:			CalculateWidth
		* Status:			Public
		* Purpose:			Calculates the width of the button
		* Author:			Doug Hennig
		* Last Revision:	12/23/2020
		* Parameters:		none
		* Returns:			none
		* Environment in:	Padding contains the desired space
		* Environment out:	the width of the button and its section has been updated
		*==============================================================================
		
		local lnCaptionWidth, ;
			lnWidth
		This.oGDI.MeasureString(This.lblButton.Caption)
		lnCaptionWidth = ceiling(This.oGDI.nWidth)
			&& This.lblButton.Width is inaccurate if the form isn't visible yet
		lnWidth        = This.lblButton.Left + lnCaptionWidth + ;
			iif(This.Menu.Count > 0, This.imgDown.Width + 5, 0)
		if This.Width <> lnWidth
			This.Width        = lnWidth
			This.imgDown.Left = This.lblButton.Left + lnCaptionWidth
		*	This.lblButton.Left = This.imgButton.Left + This.imgButton.Width + 5
		*	This.lblButton.Top  = This.imgButton.Top
		*	This.imgDown.Top    = This.imgButton.Top + int((This.imgButton.Height - This.imgDown.Height)/2)
				&& for some reason, these won't stay in the correct place at design
				&& time so uncomment these three lines
		endif This.Width <> lnWidth
		This.nLines = This.oGDI.nLines
		This.Parent.CalculateWidth()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sfribbontoolbarsection AS sfribbonbase OF "sfribbon.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="lblSection" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="linSeparator" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: addbutton		&& Adds a button to the section
		*m: addhorizontalbutton		&& Adds a horizontal button to the section
		*m: calculatewidth		&& Calculates the width of the section
		*m: caption_assign
		*p: buttonclass		&& The default button class
		*p: buttonlibrary		&& The default button library
		*p: caption		&& The caption for the section
		*p: horizontalbuttonclass		&& The default horizontal button class
		*p: horizontalbuttonlibrary		&& The default horizontal button library
	*</DefinedPropArrayMethod>

	BackStyle = 0
	buttonclass = SFRibbonToolbarButton		&& The default button class
	buttonlibrary = SFRibbon.vcx		&& The default button library
	caption = 		&& The caption for the section
	controltype = Button
	Height = 95
	horizontalbuttonclass = SFRibbonToolbarButtonHorizontal		&& The default horizontal button class
	horizontalbuttonlibrary = SFRibbon.vcx		&& The default horizontal button library
	Name = "sfribbontoolbarsection"
	padding = 8
	type = Section
	Width = 200
	_memberdata = <VFPData>
		<memberdata name="addbutton" display="AddButton"/>
		<memberdata name="caption" display="Caption"/>
		<memberdata name="caption_assign" display="Caption_Assign"/>
		<memberdata name="calculatewidth" display="CalculateWidth"/>
		<memberdata name="padding" display="Padding"/>
		<memberdata name="buttonclass" display="ButtonClass"/>
		<memberdata name="buttonlibrary" display="ButtonLibrary"/>
		<memberdata name="addhorizontalbutton" display="AddHorizontalButton"/>
		<memberdata name="horizontalbuttonclass" display="HorizontalButtonClass"/>
		<memberdata name="horizontalbuttonlibrary" display="HorizontalButtonLibrary"/>
		</VFPData>

	ADD OBJECT 'lblSection' AS label WITH ;
		Alignment = 2, ;
		BackStyle = 0, ;
		Caption = "Label1", ;
		FontName = "Segoe UI", ;
		FontSize = 8, ;
		Left = 0, ;
		Name = "lblSection", ;
		Top = 77, ;
		Width = 200, ;
		WordWrap = .T.
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'linSeparator' AS line WITH ;
		BorderColor = 179,176,173, ;
		Height = 86, ;
		Left = 198, ;
		Name = "linSeparator", ;
		Top = 5, ;
		Width = 0
		*< END OBJECT: BaseClass="line" />
	
	PROCEDURE addbutton		&& Adds a button to the section
		*==============================================================================
		* Method:			AddButton
		* Status:			Public
		* Purpose:			Adds a button to the section
		* Author:			Doug Hennig
		* Last Revision:	12/22/2020
		* Parameters:		tcName    - the name of the button (optional: if it isn't
		*						specified, Button<n> is used
		*					tcClass   - the class for the button (optional: if it isn't
		*						specified, the class in This.ButtonClass is used)
		*					tcLibrary - the library for the button class (optional: if
		*						it isn't passed, the library in This.ButtonLibrary is
		*						used)
		* Returns:			a reference to the new button
		* Environment in:	none
		* Environment out:	a button was added
		*==============================================================================
		
		lparameters tcName, ;
			tcClass, ;
			tcLibrary
		local lcName, ;
			lcClass, ;
			lcLibrary, ;
			loControl
		
		* Use defaults if the parameters weren't specified.
		
		lcName    = evl(tcName,  'Button' + transform(This.ControlCount))
		lcClass   = evl(tcClass, This.ButtonClass)
		lcLibrary = iif(pcount() = 3, tcLibrary, This.ButtonLibrary)
		
		* Have AddControl do the work.
		
		loControl = This.AddControl(lcName, lcClass, lcLibrary)
		
		* Adjust the width.
		
		This.CalculateWidth()
		return loControl
		
	ENDPROC

	PROCEDURE addhorizontalbutton		&& Adds a horizontal button to the section
		*==============================================================================
		* Method:			AddHorizontalButton
		* Status:			Public
		* Purpose:			Adds a horizontal button to the section
		* Author:			Doug Hennig
		* Last Revision:	12/28/2020
		* Parameters:		tcName    - the name of the button (optional: if it isn't
		*						specified, Button<n> is used
		*					tcClass   - the class for the button (optional: if it isn't
		*						specified, the class in This.HorizontalButtonClass is
		*						used)
		*					tcLibrary - the library for the button class (optional: if
		*						it isn't passed, the library in
		*						This.HorizontalButtonLibrary is used)
		* Returns:			a reference to the new button
		* Environment in:	none
		* Environment out:	a button was added
		*==============================================================================
		
		lparameters tcName, ;
			tcClass, ;
			tcLibrary
		return This.AddButton(tcName, This.HorizontalButtonClass, ;
			This.HorizontalButtonLibrary)
		
	ENDPROC

	PROCEDURE calculatewidth		&& Calculates the width of the section
		*==============================================================================
		* Method:			CalculateWidth
		* Status:			Public
		* Purpose:			Calculates the width of the section
		* Author:			Doug Hennig
		* Last Revision:	02/11/2021
		* Parameters:		none
		* Returns:			none
		* Environment in:	none
		* Environment out:	the position of the separator and the width of the
		*						container and the label have been updated
		*==============================================================================
		
		local lnWidth, ;
			lcType, ;
			loControl, ;
			llVertical, ;
			lnLeft, ;
			lnCaptionWidth
		lnWidth = 0
		for each loControl in This.Controls foxobject
			lcType = iif(pemstatus(loControl, 'Type', 5), loControl.Type, '')
			do case
		
		* Do nothing if this is the separator or section label or the control isn't
		* visible.
		
				case inlist(loControl.Name, 'linSeparator', 'lblSection') or ;
					(pemstatus(loControl, 'Visible', 5) and not loControl.Visible)
					&& do nothing
		
		* Horizontal button: set the Left property and if this isn't the first one,
		* set the Top property. Then increment the total width value.
		
				case lcType = 'HButton'
					if llVertical
						loControl.Top  = lnTop
						loControl.Left = lnLeft
					else
						loControl.Left = max(lnWidth, This.Padding)
						lnLeft         = loControl.Left
					endif llVertical
					lnWidth    = max(lnWidth, loControl.Left + loControl.Width)
					lnTop      = loControl.Top + loControl.Height
					llVertical = .T.
		
		* For all other controls, move the control to the next Left position and
		* increment the total width value.
		
				otherwise
					loControl.Left = max(lnWidth, This.Padding)
					lnWidth        = max(lnWidth, loControl.Left + loControl.Width)
					llVertical     = .F.
			endcase
		next loControl
		lnCaptionWidth = This.oGDI.GetWidth(This.Caption)
		This.linSeparator.Left = max(lnWidth, lnCaptionWidth) + This.Padding
		store This.linSeparator.Left to This.Width, This.lblSection.Width
		This.Parent.AdjustSections()
		
	ENDPROC

	PROCEDURE caption_assign
		lparameters tcCaption
		store tcCaption to This.Caption, This.lblSection.Caption
		
	ENDPROC

	PROCEDURE Init
		* Set the font for the SFGDIMeasureString object.
		
		dodefault()
		This.oGDI.SetFont(This.lblSection.FontName, This.lblSection.FontSize)
		
	ENDPROC

	PROCEDURE padding_assign
		lparameters tnPadding
		dodefault(tnPadding)
		This.CalculateWidth()
		
	ENDPROC

	PROCEDURE theme_assign
		lparameters tcTheme
		dodefault(tcTheme)
		This.linSeparator.BorderColor = This.GetThemeColor('sectionseparatorcolor')
		
	ENDPROC

ENDDEFINE
